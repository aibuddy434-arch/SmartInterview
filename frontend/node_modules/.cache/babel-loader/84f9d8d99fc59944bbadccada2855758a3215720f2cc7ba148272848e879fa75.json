{"ast":null,"code":"/**\r\n * Avatar Service for managing AI interviewer avatar\r\n */\nexport class AvatarService {\n  constructor() {\n    this.avatarElement = null;\n    this.isAnimating = false;\n    this.currentAudio = null;\n    this.audioContext = null;\n    this.analyser = null;\n    this.dataArray = null;\n    this.animationFrame = null;\n  }\n\n  /**\r\n   * Initialize avatar with DOM element\r\n   * @param {HTMLElement} avatarElement - Avatar DOM element\r\n   */\n  initialize(avatarElement) {\n    this.avatarElement = avatarElement;\n    this.setupAudioContext();\n    this.createAvatarVisuals();\n  }\n\n  /**\r\n   * Setup Web Audio API context for real-time audio analysis\r\n   */\n  setupAudioContext() {\n    try {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 256;\n      this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\n    } catch (error) {\n      console.warn('Web Audio API not supported, using fallback animation');\n    }\n  }\n\n  /**\r\n   * Create avatar visual elements\r\n   */\n  createAvatarVisuals() {\n    if (!this.avatarElement) return;\n\n    // Create talking head elements\n    this.avatarElement.innerHTML = `\n      <div class=\"avatar-container\">\n        <div class=\"avatar-head\">\n          <div class=\"avatar-face\">\n            <div class=\"avatar-eyes\">\n              <div class=\"avatar-eye left\"></div>\n              <div class=\"avatar-eye right\"></div>\n            </div>\n            <div class=\"avatar-mouth\">\n              <div class=\"avatar-lips\"></div>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n\n    // Add CSS classes for styling\n    this.avatarElement.classList.add('avatar-interviewer');\n  }\n\n  /**\r\n   * Start speaking animation with audio\r\n   * @param {Blob} audioBlob - Audio blob to play\r\n   * @param {string} text - Text being spoken (for fallback)\r\n   */\n  async startSpeaking(audioBlob, text = '') {\n    if (this.isAnimating) {\n      await this.stopSpeaking();\n    }\n    this.isAnimating = true;\n    try {\n      if (this.audioContext && audioBlob) {\n        await this.playAudioWithLipSync(audioBlob);\n      } else {\n        // Fallback: animate based on text length\n        this.animateWithText(text);\n      }\n    } catch (error) {\n      console.error('Failed to start speaking animation:', error);\n      // Fallback animation\n      this.animateWithText(text);\n    }\n  }\n\n  /**\r\n   * Play audio with real-time lip sync\r\n   * @param {Blob} audioBlob - Audio to play\r\n   */\n  async playAudioWithLipSync(audioBlob) {\n    try {\n      const arrayBuffer = await audioBlob.arrayBuffer();\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n      const source = this.audioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(this.analyser);\n      this.analyser.connect(this.audioContext.destination);\n      this.currentAudio = source;\n\n      // Start lip sync animation\n      this.startLipSyncAnimation();\n\n      // Play audio\n      source.start(0);\n\n      // Stop animation when audio ends\n      source.onended = () => {\n        this.stopSpeaking();\n      };\n    } catch (error) {\n      console.error('Audio playback failed:', error);\n      throw error;\n    }\n  }\n\n  /**\r\n   * Start lip sync animation based on audio frequency\r\n   */\n  startLipSyncAnimation() {\n    const animate = () => {\n      if (!this.isAnimating) return;\n      this.analyser.getByteFrequencyData(this.dataArray);\n\n      // Calculate average frequency for mouth movement\n      const average = this.dataArray.reduce((a, b) => a + b) / this.dataArray.length;\n      const normalized = average / 255; // Normalize to 0-1\n\n      // Apply mouth animation\n      this.animateMouth(normalized);\n      this.animationFrame = requestAnimationFrame(animate);\n    };\n    animate();\n  }\n\n  /**\r\n   * Animate mouth based on audio intensity\r\n   * @param {number} intensity - Audio intensity (0-1)\r\n   */\n  animateMouth(intensity) {\n    var _this$avatarElement;\n    const lips = (_this$avatarElement = this.avatarElement) === null || _this$avatarElement === void 0 ? void 0 : _this$avatarElement.querySelector('.avatar-lips');\n    if (!lips) return;\n\n    // Scale mouth based on audio intensity\n    const scale = 1 + intensity * 0.5;\n    lips.style.transform = `scaleY(${scale})`;\n\n    // Add some randomness for natural movement\n    const randomOffset = Math.random() * 0.1;\n    lips.style.transform += ` translateY(${randomOffset}px)`;\n  }\n\n  /**\r\n   * Fallback animation based on text length\r\n   * @param {string} text - Text to animate for\r\n   */\n  animateWithText(text) {\n    const duration = Math.max(text.length * 100, 2000); // 100ms per character, min 2s\n\n    this.animateMouth(0.5); // Medium intensity\n\n    setTimeout(() => {\n      this.stopSpeaking();\n    }, duration);\n  }\n\n  /**\r\n   * Stop speaking animation\r\n   */\n  async stopSpeaking() {\n    var _this$avatarElement2;\n    this.isAnimating = false;\n    if (this.currentAudio) {\n      this.currentAudio.stop();\n      this.currentAudio = null;\n    }\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n\n    // Reset mouth to neutral position\n    const lips = (_this$avatarElement2 = this.avatarElement) === null || _this$avatarElement2 === void 0 ? void 0 : _this$avatarElement2.querySelector('.avatar-lips');\n    if (lips) {\n      lips.style.transform = 'scaleY(1) translateY(0px)';\n    }\n  }\n\n  /**\r\n   * Set avatar expression\r\n   * @param {string} expression - Expression type (happy, serious, thinking, etc.)\r\n   */\n  setExpression(expression) {\n    if (!this.avatarElement) return;\n\n    // Remove previous expression classes\n    this.avatarElement.classList.remove('expression-happy', 'expression-serious', 'expression-thinking');\n\n    // Add new expression class\n    this.avatarElement.classList.add(`expression-${expression}`);\n\n    // Update visual elements based on expression\n    this.updateExpressionVisuals(expression);\n  }\n\n  /**\r\n   * Update visual elements for expression\r\n   * @param {string} expression - Expression type\r\n   */\n  updateExpressionVisuals(expression) {\n    var _this$avatarElement3, _this$avatarElement4;\n    const eyes = (_this$avatarElement3 = this.avatarElement) === null || _this$avatarElement3 === void 0 ? void 0 : _this$avatarElement3.querySelector('.avatar-eyes');\n    const mouth = (_this$avatarElement4 = this.avatarElement) === null || _this$avatarElement4 === void 0 ? void 0 : _this$avatarElement4.querySelector('.avatar-mouth');\n    if (!eyes || !mouth) return;\n    switch (expression) {\n      case 'happy':\n        eyes.style.transform = 'scaleY(0.8)';\n        mouth.style.transform = 'scaleY(1.2)';\n        break;\n      case 'serious':\n        eyes.style.transform = 'scaleY(1.2)';\n        mouth.style.transform = 'scaleY(0.8)';\n        break;\n      case 'thinking':\n        eyes.style.transform = 'scaleY(0.6)';\n        mouth.style.transform = 'scaleY(0.9)';\n        break;\n      default:\n        eyes.style.transform = 'scaleY(1)';\n        mouth.style.transform = 'scaleY(1)';\n    }\n  }\n\n  /**\r\n   * Cleanup resources\r\n   */\n  destroy() {\n    this.stopSpeaking();\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    this.avatarElement = null;\n  }\n}\n\n// Global instance\nexport const avatarService = new AvatarService();","map":{"version":3,"names":["AvatarService","constructor","avatarElement","isAnimating","currentAudio","audioContext","analyser","dataArray","animationFrame","initialize","setupAudioContext","createAvatarVisuals","window","AudioContext","webkitAudioContext","createAnalyser","fftSize","Uint8Array","frequencyBinCount","error","console","warn","innerHTML","classList","add","startSpeaking","audioBlob","text","stopSpeaking","playAudioWithLipSync","animateWithText","arrayBuffer","audioBuffer","decodeAudioData","source","createBufferSource","buffer","connect","destination","startLipSyncAnimation","start","onended","animate","getByteFrequencyData","average","reduce","a","b","length","normalized","animateMouth","requestAnimationFrame","intensity","_this$avatarElement","lips","querySelector","scale","style","transform","randomOffset","Math","random","duration","max","setTimeout","_this$avatarElement2","stop","cancelAnimationFrame","setExpression","expression","remove","updateExpressionVisuals","_this$avatarElement3","_this$avatarElement4","eyes","mouth","destroy","close","avatarService"],"sources":["D:/ai_avatar/frontend/src/services/avatarService.js"],"sourcesContent":["/**\r\n * Avatar Service for managing AI interviewer avatar\r\n */\r\nexport class AvatarService {\r\n  constructor() {\r\n    this.avatarElement = null;\r\n    this.isAnimating = false;\r\n    this.currentAudio = null;\r\n    this.audioContext = null;\r\n    this.analyser = null;\r\n    this.dataArray = null;\r\n    this.animationFrame = null;\r\n  }\r\n\r\n  /**\r\n   * Initialize avatar with DOM element\r\n   * @param {HTMLElement} avatarElement - Avatar DOM element\r\n   */\r\n  initialize(avatarElement) {\r\n    this.avatarElement = avatarElement;\r\n    this.setupAudioContext();\r\n    this.createAvatarVisuals();\r\n  }\r\n\r\n  /**\r\n   * Setup Web Audio API context for real-time audio analysis\r\n   */\r\n  setupAudioContext() {\r\n    try {\r\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n      this.analyser = this.audioContext.createAnalyser();\r\n      this.analyser.fftSize = 256;\r\n      this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n    } catch (error) {\r\n      console.warn('Web Audio API not supported, using fallback animation');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create avatar visual elements\r\n   */\r\n  createAvatarVisuals() {\r\n    if (!this.avatarElement) return;\r\n\r\n    // Create talking head elements\r\n    this.avatarElement.innerHTML = `\r\n      <div class=\"avatar-container\">\r\n        <div class=\"avatar-head\">\r\n          <div class=\"avatar-face\">\r\n            <div class=\"avatar-eyes\">\r\n              <div class=\"avatar-eye left\"></div>\r\n              <div class=\"avatar-eye right\"></div>\r\n            </div>\r\n            <div class=\"avatar-mouth\">\r\n              <div class=\"avatar-lips\"></div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    `;\r\n\r\n    // Add CSS classes for styling\r\n    this.avatarElement.classList.add('avatar-interviewer');\r\n  }\r\n\r\n  /**\r\n   * Start speaking animation with audio\r\n   * @param {Blob} audioBlob - Audio blob to play\r\n   * @param {string} text - Text being spoken (for fallback)\r\n   */\r\n  async startSpeaking(audioBlob, text = '') {\r\n    if (this.isAnimating) {\r\n      await this.stopSpeaking();\r\n    }\r\n\r\n    this.isAnimating = true;\r\n    \r\n    try {\r\n      if (this.audioContext && audioBlob) {\r\n        await this.playAudioWithLipSync(audioBlob);\r\n      } else {\r\n        // Fallback: animate based on text length\r\n        this.animateWithText(text);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to start speaking animation:', error);\r\n      // Fallback animation\r\n      this.animateWithText(text);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play audio with real-time lip sync\r\n   * @param {Blob} audioBlob - Audio to play\r\n   */\r\n  async playAudioWithLipSync(audioBlob) {\r\n    try {\r\n      const arrayBuffer = await audioBlob.arrayBuffer();\r\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\r\n      \r\n      const source = this.audioContext.createBufferSource();\r\n      source.buffer = audioBuffer;\r\n      source.connect(this.analyser);\r\n      this.analyser.connect(this.audioContext.destination);\r\n      \r\n      this.currentAudio = source;\r\n      \r\n      // Start lip sync animation\r\n      this.startLipSyncAnimation();\r\n      \r\n      // Play audio\r\n      source.start(0);\r\n      \r\n      // Stop animation when audio ends\r\n      source.onended = () => {\r\n        this.stopSpeaking();\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('Audio playback failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start lip sync animation based on audio frequency\r\n   */\r\n  startLipSyncAnimation() {\r\n    const animate = () => {\r\n      if (!this.isAnimating) return;\r\n      \r\n      this.analyser.getByteFrequencyData(this.dataArray);\r\n      \r\n      // Calculate average frequency for mouth movement\r\n      const average = this.dataArray.reduce((a, b) => a + b) / this.dataArray.length;\r\n      const normalized = average / 255; // Normalize to 0-1\r\n      \r\n      // Apply mouth animation\r\n      this.animateMouth(normalized);\r\n      \r\n      this.animationFrame = requestAnimationFrame(animate);\r\n    };\r\n    \r\n    animate();\r\n  }\r\n\r\n  /**\r\n   * Animate mouth based on audio intensity\r\n   * @param {number} intensity - Audio intensity (0-1)\r\n   */\r\n  animateMouth(intensity) {\r\n    const lips = this.avatarElement?.querySelector('.avatar-lips');\r\n    if (!lips) return;\r\n    \r\n    // Scale mouth based on audio intensity\r\n    const scale = 1 + (intensity * 0.5);\r\n    lips.style.transform = `scaleY(${scale})`;\r\n    \r\n    // Add some randomness for natural movement\r\n    const randomOffset = Math.random() * 0.1;\r\n    lips.style.transform += ` translateY(${randomOffset}px)`;\r\n  }\r\n\r\n  /**\r\n   * Fallback animation based on text length\r\n   * @param {string} text - Text to animate for\r\n   */\r\n  animateWithText(text) {\r\n    const duration = Math.max(text.length * 100, 2000); // 100ms per character, min 2s\r\n    \r\n    this.animateMouth(0.5); // Medium intensity\r\n    \r\n    setTimeout(() => {\r\n      this.stopSpeaking();\r\n    }, duration);\r\n  }\r\n\r\n  /**\r\n   * Stop speaking animation\r\n   */\r\n  async stopSpeaking() {\r\n    this.isAnimating = false;\r\n    \r\n    if (this.currentAudio) {\r\n      this.currentAudio.stop();\r\n      this.currentAudio = null;\r\n    }\r\n    \r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame);\r\n      this.animationFrame = null;\r\n    }\r\n    \r\n    // Reset mouth to neutral position\r\n    const lips = this.avatarElement?.querySelector('.avatar-lips');\r\n    if (lips) {\r\n      lips.style.transform = 'scaleY(1) translateY(0px)';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set avatar expression\r\n   * @param {string} expression - Expression type (happy, serious, thinking, etc.)\r\n   */\r\n  setExpression(expression) {\r\n    if (!this.avatarElement) return;\r\n    \r\n    // Remove previous expression classes\r\n    this.avatarElement.classList.remove('expression-happy', 'expression-serious', 'expression-thinking');\r\n    \r\n    // Add new expression class\r\n    this.avatarElement.classList.add(`expression-${expression}`);\r\n    \r\n    // Update visual elements based on expression\r\n    this.updateExpressionVisuals(expression);\r\n  }\r\n\r\n  /**\r\n   * Update visual elements for expression\r\n   * @param {string} expression - Expression type\r\n   */\r\n  updateExpressionVisuals(expression) {\r\n    const eyes = this.avatarElement?.querySelector('.avatar-eyes');\r\n    const mouth = this.avatarElement?.querySelector('.avatar-mouth');\r\n    \r\n    if (!eyes || !mouth) return;\r\n    \r\n    switch (expression) {\r\n      case 'happy':\r\n        eyes.style.transform = 'scaleY(0.8)';\r\n        mouth.style.transform = 'scaleY(1.2)';\r\n        break;\r\n      case 'serious':\r\n        eyes.style.transform = 'scaleY(1.2)';\r\n        mouth.style.transform = 'scaleY(0.8)';\r\n        break;\r\n      case 'thinking':\r\n        eyes.style.transform = 'scaleY(0.6)';\r\n        mouth.style.transform = 'scaleY(0.9)';\r\n        break;\r\n      default:\r\n        eyes.style.transform = 'scaleY(1)';\r\n        mouth.style.transform = 'scaleY(1)';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  destroy() {\r\n    this.stopSpeaking();\r\n    \r\n    if (this.audioContext) {\r\n      this.audioContext.close();\r\n      this.audioContext = null;\r\n    }\r\n    \r\n    this.avatarElement = null;\r\n  }\r\n}\r\n\r\n// Global instance\r\nexport const avatarService = new AvatarService();\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}